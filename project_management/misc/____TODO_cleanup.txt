* offizielles sample projekt starten (generell, fuer alle eigenen artifakte!)


	public static double convertScaleValue(double fromValue, double fromMin, double fromMax, double toMin, double toMax) {
		double fromDiff = fromMax - fromMin; // Figure out the from range
		double toDiff = toMax - toMin;       // Figure out the to range
		
		// Find the percentage
		double position = fromValue / fromDiff;
		double newValue = toDiff * position;
		
		return toMin + newValue;
	}







  private Vec2f screenToNormalizedCoordinates(CameraParameters params,
                                              int x, int y) {
    // AWT's origin is upper left
    return new Vec2f(
      (((float) x / (float) (params.xSize - 1)) - 0.5f) * 2.0f,
      (0.5f - ((float) y / (float) (params.ySize - 1))) * 2.0f
    );
  }
  
  
  
  
If you read it carefully, you'll see that one solution to use JNI libraries is to bundle them in architecture specific
	JARs so that you can depend on them like any other dependency from a Maven point of view.
	This is actually how JOGL version 1.1.1 is packaged in http://download.java.net/maven/2/net/java/dev/jogl/,
	there is one JAR artifact with the Java classes and several architecture specific JARs artifacts with the native libraries. 
	[http://stackoverflow.com/questions/1962718/maven-and-the-jogl-library]
	// to load JNIs from classpath, use some: NativeLoader.loadLibrary("foolib");


    private:
        thread(thread&);
        thread& operator=(thread&);




string cstr_to_str(const char * str)
{
string tmp_str(str);
return tmp_str;
}


char * str_to_cstr(const string& s)
{
char * result = new char[s.size() + 1];
strcpy(result, s.c_str());
return result;
}








MACRO(INSTALL_HEADERS_WITH_DIRECTORY HEADER_LIST)
 
FOREACH(HEADER ${${HEADER_LIST}})
    STRING(REGEX MATCH "(.*)[/\\]" DIR ${HEADER})
    INSTALL(FILES ${HEADER} DESTINATION include/${DIR})
ENDFOREACH(HEADER)
 
ENDMACRO(INSTALL_HEADERS_WITH_DIRECTORY)
 
INSTALL_HEADERS_WITH_DIRECTORY(HS)






/** Marks the beginning of a message map of a specific module. */ 
#define XN_STATUS_MESSAGE_MAP_START_FROM(group, first)		\
	enum _##group##first##Errors							\
	{														\
		group##first##_OK = XN_STATUS_MAKE(group, first),





#elif XN_PLATFORM_VAARGS_TYPE == XN_PLATFORM_USE_NO_VAARGS
	#define xnLogVerbose(csLogMask, csFormat, args)	xnLogWrite(csLogMask, XN_LOG_VERBOSE, __FILE__, __LINE__, csFormat, args)
	#define xnLogInfo(csLogMask, csFormat, args)	xnLogWrite(csLogMask, XN_LOG_INFO, __FILE__, __LINE__, csFormat, args)
	#define xnLogWarning(csLogMask, csFormat, args)	xnLogWrite(csLogMask, XN_LOG_WARNING, __FILE__, __LINE__, csFormat, args)
	#define xnLogError(csLogMask, csFormat, args)	xnLogWrite(csLogMask, XN_LOG_ERROR, __FILE__, __LINE__, csFormat, args)

XN_C_API void xnLogWrite(const XnChar* csLogMask, XnLogSeverity nSeverity, const XnChar* csFile, XnUInt32 nLine, const XnChar* csFormat, ...);








XnUSBLinux-x86.cpp#xnUSBOpenDeviceImpl:

rc = libusb_claim_interface(handle, 0);
	if (rc != 0)
	{
		libusb_close(handle);
		return (XN_STATUS_USB_SET_INTERFACE_FAILED);
	}