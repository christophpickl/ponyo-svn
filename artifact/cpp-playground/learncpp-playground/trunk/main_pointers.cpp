#include <stdio.h>

#include <algorithm> // for std::copy

//class Data {
//public:
//	Data() {
//		printf("new Data()\n");
//	}
//	~Data() {
//		printf("~Data()\n");
//	}
//};

class Foo {
public:

	int x;
	int* dataArray;

	// rule of three: destructor, copy constructor, copy assignment operator
	//   "If you need a copy constructor, you also need a destructor and operator="
	// ... like equals and hashCode ;)

	// explicit constructor
	Foo(int pX) : x(pX), dataArray(new int[1]) {
		printf("new Foo(%i)\n", pX);
	}

	// explicit destructor
	~Foo() {
		printf("~Foo(%i)\n", this->x);
		delete[] this->dataArray;
	}

	// user-defined copy constructor
	// The Foo& form of the copy constructor is used when it is necessary to modify the copied object
	Foo(const Foo& copy) :
		x(copy.x)
		, dataArray(new int[1]) // allocate new/fresh/independent memory
//		, dataArray(copy.dataArray) // would have been generated by default by compiler
		{
		printf("new Foo(copy.x=%i)\n", copy.x);
		// this->x would have been necessary to initialize explicitly, if not have done via arg list

		std::copy(copy.dataArray, copy.dataArray + 1, this->dataArray); // deep copy data!
	}

	inline void swap(Foo& other) { // the swap member function (should never fail!)
		// swap all the members (and base subobject, if applicable) with other
		std::swap(this->dataArray, other.dataArray);
		std::swap(x, other.x);
	}
	Foo& operator=(Foo other) { // note: argument passed by value! therefore copy constructor will be implicitly invoked
		printf("operator=(other.x=%i) ... this->x=%i\n", other.x, this->x);
		swap(other); // swap this with other
		return *this; // by convention, always return *this
		// other is destroyed, releasing the memory => ~Foo() for other
	}

	// naive implementation
//	Foo& operator=(const Foo& other) {
//		printf("operator=(other.x=%i) ... this->x=%i\n", other.x, this->x);
//		if (this != &other) { // protect against invalid self-assignment
//			// 1: allocate new memory and copy the elements
//			int * new_array = new int[1];
//			std::copy(other.dataArray, other.dataArray + 1, new_array);
//			// 2: deallocate old memory
//			delete[] this->dataArray;
//			// 3: assign the new memory to the object
//			this->dataArray = new_array;
//
//			this->x = other.x;
//		}
//		return *this; // by convention, always return *this
//	}

	int getX() const {
		return this->x;
	}

	void doitPassCopy(Foo that, int x2) {
		printf("Foo.doitPassCopy(that.x=%i, x2=%i)\n", that.x, x2);
		that.x = x2;
	}
	void doitPassRef(Foo* that, int x2) {
			printf("Foo.doitPassRef(that.x=%i, x2=%i)\n", that->x, x2);
			that->x = x2;
	}
	void doitGettingSelfRef(Foo& that, int x2) {
		printf("Foo.doitGettingSelfRef(that.x=%i, x2=%i)\n", that.x, x2);
		that.x = x2;
	}
};

void provokeSegFault() {
	printf("provokeSegFault()\n");
	Foo f1(1);
	{
		printf(">> Foo copy = f1;\n");
		Foo copy = f1;
		copy.x = 11;
	} // ~copy implicit call
	printf("provokeSegFault() END\n");

//	printf(">> f1.dataArray; ... expecting NOOO SEG FAULT!!!\n");
//	f1.dataArray // ==> SEG FAULT!!! ... NO, as deep copy is done
}

void fooRef() {
	new Foo(42);
//	Foo* f = new Foo(42);
}

void fooNonRef() {
	Foo f(42);
}

#define PRINTFS(prefix) \
printf("===> %s:\n", prefix); \
printf("\tf1->x=%i\n", f1->x); \
printf("\tf2->x=%i\n", f2->x); \
printf("\tf3.x=%i\n\n", f3.x);


void fooHardInternal1_creatingNonRefInstance(Foo** original, int& bar) {
//	Foo newLocal(11);
//	original = &newLocal;
	Foo* newOrig = new Foo(111);
	*original = newOrig; // introduces memory leak, as "orig = new Foo(0)" will never be deleted (deleted orig references newOrig)
	bar = 77;
}

Foo returnByCopyConstructor() {
	Foo f(1337);
	return f;
}
void doWithValueArg(Foo f) {
	printf("doWithValueArg(f.x=%i)\n", f.x);
	Foo* fHacked = &f;
	fHacked->x = 99999; // wuhaha, you cant hack me! ;) ... as you only got a copy-constructor instance
}

void fooHardcore() {
	printf("fooHardcore() START\n\n");

	printf("hardcopy - START\n");

	printf(">> Foo fc1(881);\n");
	Foo fc1(881);

	printf(">> Foo* fc2ref = new Foo(882);\n");
	Foo* fc2ref = new Foo(882);

	printf(">> Foo fc2 = fc1;\n");
	Foo fc2 = fc1;

	printf(">> Foo fc2ByRef(*fc2ref);\n");
	Foo fc2ByRef(*fc2ref);

	printf(">> Foo* fc3ref = new Foo(fc1);\n");
	Foo* fc1refByVal = new Foo(fc1);

	printf(">> Foo* fc2refByRef = new Foo(*fc2ref);\n");
	Foo* fc2refByRef = new Foo(*fc2ref);

	printf(">> Foo fc1valByVal(fc1);\n");
	Foo fc1valByVal(fc1);

	printf("hardcopy - fc1.x: %i\n", fc1.x); // ==> 881
	printf("hardcopy - fc2.x: %i\n", fc2.x); // ==> 881
	printf("hardcopy - fc2ByRef.x: %i\n", fc2ByRef.x); // ==> 882
	printf("hardcopy - fc1refByVal->x: %i\n", fc1refByVal->x); // ==> 881
	printf("hardcopy - fc2refByRef->x: %i\n", fc2refByRef->x); // ==> 882
	printf("hardcopy - fc1valByVal.x: %i\n", fc1valByVal.x); // ==> 881
	delete fc1refByVal;
	delete fc2ref;
	delete fc2refByRef;
	printf("hardcopy - END\n\n");

	printf("returnByCopyConstructor() START\n");
	Foo fReturned = returnByCopyConstructor();
	printf("returnByCopyConstructor() END\n\n");

	printf("doWithValueArg() ... fMyValArg(99) START\n");
	Foo fMyValArg(99);
	doWithValueArg(fMyValArg);
	printf("doWithValueArg() ... fMyValArg.x=%i END\n\n", fMyValArg.x);

	Foo* orig = new Foo(0);
	int bar = 1;
	printf("hard - initial: %i\n", orig->x);
	fooHardInternal1_creatingNonRefInstance(&orig, bar);

	printf("hard - after internal1: %i\n", orig->x);
	printf("bar - after internal1: %i\n", bar);

	printf("hard - delete orig\n");
	delete orig;
	printf("fooHardcore() END\n");
}

int main() {
	printf("main() START\n");

	Foo* f = new Foo(0);
	Foo* f1 = new Foo(1);
	Foo* f2 = new Foo(2);
	Foo f3(3);
	Foo f4(4);

	PRINTFS("initial");
	printf("\tf4.x=%i\n", f4.x);

	printf(">> f4 = f3;\n");
	f4 = f3;
	// this single assignment gnerates following output:
	//   new Foo(copy.x=3)
	//   operator=(other.x=3) ... this->x=4
	//   ~Foo(4)
	printf("\tf4.x=%i\n", f4.x);

	f->doitPassCopy(*f1, 15);
	f->doitPassCopy(f3, 35);

	PRINTFS("after doitPassCopy(15, 35);\n");

	f->doitPassRef(f1, 16);
	f->doitPassRef(&f3, 36);

	PRINTFS("after doitPassRef(16, 36)");

	f->doitGettingSelfRef(*f2, 27);
	f->doitGettingSelfRef(f3, 37);

	PRINTFS("after doitGettingSelfRef(27, 37)");

	printf("delete f1, f2\n");
//	int f1x = f1->getX();
//	printf("f1->x=%i\n", f1->x);
//	f1x = 77; // NOT POSSIBLE, as accessor method is declared const!
//	printf("f1->x=%i\n", f1->x);
	delete f1;
	delete f2;

	printf("\n======================== FOO (NON) REF\n\n");

	printf("====> fooRef()\n");
	fooRef();
	printf("-----------------\n\n");
	printf("====> fooNonRef()\n");
	fooNonRef();
	printf("-----------------\n\n");


	printf("\n======================== FOO HARDCORE\n\n");
	fooHardcore();

	printf("\n======================== FOO NEARLY SEG FAULT\n\n");
	provokeSegFault();

	printf("\n\nmain() END\n");

	return 0;
}

